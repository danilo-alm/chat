package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/reflection"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/timestamppb"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	pb "auth-service/pb"
	userpb "auth-service/user-pb"
)

type server struct {
	pb.UnimplementedAuthServiceServer
	userClient    userpb.UserServiceClient
	mariadbClient *gorm.DB
}

type User struct {
	Id       string         `gorm:"primaryKey"`
	Password string         `gorm:"not null"`
	Tokens   []RefreshToken `gorm:"foreignKey:UserId;references:Id"`
}

type RefreshToken struct {
	Id        uint      `gorm:"primaryKey"`
	UserId    string    `gorm:"not null;index"`
	Token     string    `gorm:"not null;uniqueIndex;size:512"`
	CreatedAt time.Time `gorm:"autoCreateTime"`
	ExpiresAt time.Time `gorm:"not null"`
}

const (
	accessTTL  = 24 * time.Hour
	refreshTTL = 7 * 24 * time.Hour
)

var (
	accessSecret  = []byte(getEnv("ACCESS_TOKEN_SECRET", "dev-access-secret"))
	refreshSecret = []byte(getEnv("REFRESH_TOKEN_SECRET", "dev-refresh-secret"))
)

func main() {
	port := getEnv("GRPC_PORT", "50051")
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	user_service_addr := getEnv("USER_SERVICE_ADDR", "user-service:50051")
	conn, err := grpc.NewClient(user_service_addr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Fatalf("Failed to connect to User Service: %v", err)
	}
	defer conn.Close()

	db_uri := getEnv("MARIADB_URI", "user:secret@tcp(auth-db:3306)/authdb")
	dsn := fmt.Sprintf("%s?charset=utf8mb4&parseTime=True&loc=Local", db_uri)
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}

	db.AutoMigrate(&User{}, &RefreshToken{})

	userServiceClient := userpb.NewUserServiceClient(conn)

	authServer := &server{
		userClient:    userServiceClient,
		mariadbClient: db,
	}

	s := grpc.NewServer()
	pb.RegisterAuthServiceServer(s, authServer)

	enable_reflection := getEnv("REFLECTION", "false")
	log.Println("Reflection enabled:", enable_reflection)
	if enable_reflection == "true" {
		reflection.Register(s)
	}

	log.Println("gRPC server started on port", port)
	if err := s.Serve(lis); err != nil {
		log.Fatalf("Failed to serve: %v", err)
	}
}

func (s *server) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
	returnValue := &pb.CreateUserResponse{}

	hashedPassword, err := hashPassword(req.GetPassword())
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to hash password")
	}

	err = s.mariadbClient.Transaction(func(tx *gorm.DB) error {
		user := User{
			Password: hashedPassword,
		}

		if err := tx.Create(&user).Error; err != nil {
			return status.Errorf(codes.Internal, "failed to insert auth user")
		}

		resp, err := s.userClient.CreateUser(ctx, &userpb.CreateUserRequest{
			User: &userpb.User{
				Id:       user.Id, // generated by BeforeCreate()
				Username: req.GetUsername(),
				Name:     req.GetName(),
			},
		})
		if err != nil {
			return status.Errorf(codes.Internal, "failed to call UserService: %v", err)
		}

		returnValue.Id = resp.GetId()
		return nil
	})

	if err != nil {
		return nil, err
	}
	return returnValue, nil
}

func (s *server) Login(ctx context.Context, req *pb.LoginRequest) (*pb.LoginResponse, error) {
	userDetails, err := s.userClient.GetUserByUsername(
		ctx, &userpb.GetUserByUsernameRequest{Username: req.GetUsername()})
	if err != nil {
		return nil, err
	}

	var userCredentials User
	userId := userDetails.GetUser().GetId()
	if err = s.mariadbClient.Where("id = ?", userId).First(&userCredentials).Error; err != nil {
		return nil, status.Error(codes.Unauthenticated, "invalid credentials")
	}
	if !checkPasswordHash(req.GetPassword(), userCredentials.Password) {
		return nil, status.Error(codes.Unauthenticated, "invalid credentials")
	}

	access, accessExp, err := signAccessToken(userId)
	if err != nil {
		return nil, status.Error(codes.Internal, "failed to sign access token")
	}
	refresh, refreshExp, err := signRefreshToken(userId)
	if err != nil {
		return nil, status.Error(codes.Internal, "failed to sign refresh token")
	}
	if err := saveRefreshToken(s.mariadbClient, userId, refresh, refreshExp); err != nil {
		return nil, status.Error(codes.Internal, "failed to persist refresh token")
	}

	return &pb.LoginResponse{
		UserId:                userId,
		Username:              req.Username,
		AccessToken:           access,
		AccessTokenExpiresAt:  timestamppb.New(accessExp),
		RefreshToken:          refresh,
		RefreshTokenExpiresAt: timestamppb.New(refreshExp),
	}, nil
}

func signAccessToken(userId string) (string, time.Time, error) {
	return issueToken(userId, accessTTL, accessSecret)
}

func signRefreshToken(userId string) (string, time.Time, error) {
	return issueToken(userId, refreshTTL, refreshSecret)
}

func issueToken(userId string, TTL time.Duration, secret []byte) (string, time.Time, error) {
	now := time.Now()
	exp := now.Add(TTL)
	claims := jwt.RegisteredClaims{
		Subject:   userId,
		ID:        uuid.NewString(),
		IssuedAt:  jwt.NewNumericDate(now),
		ExpiresAt: jwt.NewNumericDate(exp),
	}
	t := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	s, err := t.SignedString(secret)
	return s, exp, err
}

func saveRefreshToken(db *gorm.DB, userId, token string, exp time.Time) error {
	rt := &RefreshToken{
		UserId:    userId,
		Token:     token,
		ExpiresAt: exp,
	}
	return db.Save(&rt).Error
}

func hashPassword(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hash), err
}

func checkPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
	if u.Id == "" {
		u.Id = uuid.New().String()
	}
	return
}

func getEnv(key string, defaultValue string) string {
	if val := os.Getenv(key); val != "" {
		return val
	}
	return defaultValue
}
