package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/reflection"
	"google.golang.org/grpc/status"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	pb "auth-service/pb"
	userpb "auth-service/user-pb"
)

type server struct {
	pb.UnimplementedAuthServiceServer
	userClient    userpb.UserServiceClient
	mariadbClient *gorm.DB
}

type User struct {
	Id       string         `gorm:"primaryKey"`
	Password string         `gorm:"not null"`
	Tokens   []RefreshToken `gorm:"foreignKey:UserId;references:Id"`
}

type RefreshToken struct {
	UserId    uint      `gorm:"primaryKey;not null"`
	Token     string    `gorm:"primaryKey;not null"`
	ExpiresAt time.Time `gorm:"not null"`
}

func main() {
	dsn := "user:secret@tcp(auth-db:3306)/authdb?charset=utf8mb4&parseTime=True&loc=Local"
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal(err)
	}

	db.AutoMigrate(&User{}, &RefreshToken{})

	port := getEnv("GRPC_PORT", "50051")
	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	user_service_addr := getEnv("USER_SERVICE_ADDR", "user-service:50051")
	conn, err := grpc.NewClient(user_service_addr)
	if err != nil {
		log.Fatalf("Failed to connect to User Service: %v", err)
	}
	defer conn.Close()

	userServiceClient := userpb.NewUserServiceClient(conn)

	authServer := &server{
		userClient:    userServiceClient,
		mariadbClient: db,
	}

	s := grpc.NewServer()
	pb.RegisterAuthServiceServer(s, authServer)

	enable_reflection := getEnv("REFLECTION", "false")
	log.Println("Reflection enabled:", enable_reflection)
	if enable_reflection == "true" {
		reflection.Register(s)
	}

	log.Println("gRPC server started on port", port)
	if err := s.Serve(lis); err != nil {
		log.Fatalf("Failed to serve: %v", err)
	}
}

func (s *server) CreateUser(ctx context.Context, req *pb.CreateUserRequest) (*pb.CreateUserResponse, error) {
	returnValue := &pb.CreateUserResponse{}

	hashedPassword, err := hashPassword(req.GetPassword())
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to hash password")
	}

	err = s.mariadbClient.Transaction(func(tx *gorm.DB) error {
		user := User{
			Password: hashedPassword,
		}

		if err := tx.Create(&user).Error; err != nil {
			return status.Errorf(codes.Internal, "failed to insert auth user")
		}

		resp, err := s.userClient.CreateUser(ctx, &userpb.CreateUserRequest{
			User: &userpb.User{
				Id:       user.Id, // generated by BeforeCreate()
				Username: req.GetUsername(),
				Name:     req.GetName(),
			},
		})
		if err != nil {
			return status.Errorf(codes.Internal, "failed to call UserService: %v", err)
		}

		returnValue.Id = resp.GetId()
		return nil
	})

	if err != nil {
		return nil, err // rollback happens automatically
	}
	return returnValue, nil
}

func (u *User) BeforeCreate(tx *gorm.DB) (err error) {
	if u.Id == "" {
		u.Id = uuid.New().String()
	}
	return
}

func hashPassword(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(hash), err
}

func checkPasswordHash(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}

func getEnv(key string, defaultValue string) string {
	if val := os.Getenv(key); val != "" {
		return val
	}
	return defaultValue
}
